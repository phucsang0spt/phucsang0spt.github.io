<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>AlphaTab Tutorial</title>
    <!-- <script src="https://cdn.jsdelivr.net/npm/@coderline/alphatab@latest/dist/alphaTab.js"></script> -->
    <script src="core.js"></script>
    <script src="https://kit.fontawesome.com/b43f0e512e.js"></script>
    <script src="debounce.min.js"></script>
    <style type="text/css">
      body {
        font-family: Arial, Helvetica, sans-serif;
        font-size: 12px;
        margin: 0;
        padding: 0;
      }

      .at-wrap {
        width: 100vw;
        height: 100vh;
        position: relative;
        overflow: hidden;
      }
      .at-viewport {
        overflow-y: auto;
        max-height: 100%;
      }

      .at-main {
        pointer-events: all;
        -webkit-touch-callout: none; /* iOS Safari */
        -webkit-user-select: none; /* Safari */
        -khtml-user-select: none; /* Konqueror HTML */
        -moz-user-select: none; /* Old versions of Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
        user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome, Edge, Opera and Firefox */
      }

      .at-cursor-bar:not(.range-mode) {
        /* Defines the color of the bar background when a bar is played */
        background: rgba(255, 242, 0, 0.25);
      }

      .track-bar {
        position: absolute;
        background-color: #27ae60;
        z-index: 2;
        width: 4px;
      }

      .track-bar > div {
        position: relative;
        width: 100%;
        height: 100%;
      }
      .track-bar > div::before {
        content: "";
        position: absolute;
        top: 0;
        left: 50%;
        width: 0px;
        height: 0px;
        border-left: 16px solid transparent;
        border-right: 16px solid transparent;
        border-top: 32px solid #27ae60;
        border-bottom: 32px solid transparent;
        transform: translateX(calc(-50%));
      }

      .track-bar > div::after {
        content: "";
        position: absolute;
        bottom: 0;
        left: 50%;
        width: 0px;
        height: 0px;
        border-left: 16px solid transparent;
        border-right: 16px solid transparent;
        border-bottom: 32px solid #27ae60;
        border-top: 32px solid transparent;
        transform: translateX(calc(-50%));
      }
      .at-surface.highlight > div:nth-child(n + 4):nth-last-child(n + 3) {
        /* border: 2px solid rgba(56, 68, 234, 0.763); */
        background-color: #7fbafd15;
      }
      .at-selection > div {
        /* Defines the color of the selection background */
        /* background-color: #27ae5f69; */
        background-color: transparent;
        position: relative;
      }

      .at-cursor-beat {
        /* Defines the beat cursor */
        background: rgba(64, 64, 255, 0.75);
        width: 3px;
      }

      .at-highlight * {
        /* Defines the color of the music symbols when they are being played (svg) */
        fill: #0078ff;
        stroke: #0078ff;
      }

      .loader {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #ffffff30;
      }
    </style>
  </head>

  <body>
    <template id="tl_track-bar">
      <div class="track-bar">
        <div></div>
      </div>
    </template>
    <div class="at-wrap">
      <div class="at-viewport">
        <div class="at-main"></div>
      </div>
      <div id="loader" class="loader">
        <img src="./loading.svg" alt="" />
      </div>
    </div>

    <script type="text/javascript">
      // load elements
      const wrapper = document.querySelector(".at-wrap");
      const main = wrapper.querySelector(".at-main");
      const loader = document.getElementById("loader");
      const viewport = wrapper.querySelector(".at-viewport");

      function ticksToMillis(ticks, tempo) {
        return (ticks * (60000.0 / (tempo * 960))) | 0;
      }

      function trackToJSON(track) {
        return {
          id: track.index,
          name: track.name,
          isMute: getTrackMuteState(track),
        };
      }

      function getTrackMuteState(track) {
        if (track.playbackInfo.isOn) {
          return false; // currently not mute yet
        }
        return true;
      }

      function onOffTrack(track) {
        window.sheetEngine.changeTrackMute([track], getTrackMuteState(track)); // mute or on track
      }

      async function genTrackBar() {
        await new Promise((res) => setTimeout(res, 200));
        const runBar = main.querySelectorAll(".at-cursor-beat")[0];

        // get position from translate
        const pos = (runBar.style.transform.match(
          /translate\(([0-9|\.]+px,\s?[0-9|\.]+px)\)/
        ) || [])[1]?.split(/,\s?/);

        // get scale from translate
        const scale = (runBar.style.transform.match(
          /scale\(([0-9|\.]+,\s?[0-9|\.]+)\)/
        ) || [])[1]?.split(/,\s?/);

        const height = runBar.style.height;

        const trackBar = document
          .getElementById("tl_track-bar")
          .content.cloneNode(true);
        trackBar.children[0].setAttribute(
          "style",
          `left:${pos[0]}; top:${pos[1]}; height: calc(${height} * ${scale[1]})`
        );

        runBar.parentElement.appendChild(trackBar);

        return trackBar;
      }

      function clearPlaybackRange() {
        const sheetEngine = window.sheetEngine;
        sheetEngine.clickTrack = {};
        sheetEngine.playbackRange = null;
        // clear all bar
        const bars = main.querySelectorAll(".track-bar");
        bars.forEach((bar) => bar.remove());
      }

      function onRangeMode() {
        const atCursor = main.querySelector(".at-cursors");
        const surface = main.querySelector(".at-surface");
        window.sheetEngine.isLooping = true;
        window.sheetEngine.createRangeMode = true;
        surface.classList.add("highlight");
        atCursor.querySelector(".at-cursor-bar").classList.add("range-mode");
        emitEventToApp({
          event: "onRangeModeChanged",
          payload: true,
        });
      }

      function offRangeMode() {
        const atCursor = main.querySelector(".at-cursors");
        const surface = main.querySelector(".at-surface");
        window.sheetEngine.isLooping = false;
        window.sheetEngine.createRangeMode = false; // set flag off

        // off range mode style
        surface.classList.remove("highlight");
        atCursor.querySelector(".at-cursor-bar").classList.remove("range-mode");
        clearPlaybackRange();

        //
        emitEventToApp({
          event: "onRangeModeChanged",
          payload: false,
        });
      }

      function toggleRangeMode() {
        window.sheetEngine.pause();
        if (!window.sheetEngine.createRangeMode) {
          onRangeMode();
        } else {
          offRangeMode();
        }
      }

      function replaySheet() {
        // off range mode before reset
        offRangeMode();
        window.sheetEngine.player.timePosition = 0;
        window.sheetEngine.updateSettings();
        window.sheetEngine.render();
      }

      function playTrack(id) {
        // off range mode before change track
        offRangeMode();
        const track = window.hashTracks[id];
        window.sheetEngine.renderTracks([track]);
      }

      function toggleTrackVolume(id) {
        const track = window.hashTracks[id];
        track.playbackInfo.isOn = !track.playbackInfo.isOn;
        emitEventToApp({
          event: "onTrackMuteChanged",
          payload: {
            id: id,
            mute: getTrackMuteState(track),
          },
        });
        onOffTrack(track);
      }

      window.emitEventToApp = window.ReactNativeWebView
        ? function (obj) {
            window.ReactNativeWebView.postMessage(
              `event::${JSON.stringify(obj)}`
            );
          }
        : function noop() {};

      const emitOnPlayerPositionChanged = _.throttle((payload) => {
        emitEventToApp({
          event: "onPlayerPositionChanged",
          payload,
        });
      }, 10);

      async function bootstrap(data) {
        window.hashTracks = {};

        if (window.sheetEngine) {
          window.sheetEngine.stop();
          window.sheetEngine.destroyPlayer();
          window.sheetEngine = undefined;
        }
        // initialize alphatab
        const HarmonicType = alphaTab.model.HarmonicType;
        const BendType = alphaTab.model.BendType;
        const api = new alphaTab.AlphaTabApi(main, {
          file: data,
          player: {
            enablePlayer: true,
            soundFont: "./sonivox.sf2",
            scrollElement: viewport,
          },
        });

        //   api.countInVolume = 1;
        //   api.metronomeVolume = 1;
        //   api.isLooping = loop.classList.contains("active");

        //   api.settings.display.layoutMode = alphaTab.LayoutMode.Horizontal;
        //   api.settings.display.layoutMode = alphaTab.LayoutMode.Page;

        api.settings.display.scale = 2;
        api.isLooping = false;
        api.playbackRange = null;
        api.totalTick = null;
        api.clickTrack = { left: null, right: null };
        api.createRangeMode = false;
        api.trackTickList = [];
        api.lastTimePosition = 0;
        window.sheetEngine = api;

        async function handleClickLine(tick) {
          if (!api.createRangeMode) {
            return;
          }
          api.pause();

          if (!api.clickTrack.left) {
            // set left bar
            const tickDuration = api._currentBeat.tickDuration;
            const bar = await genTrackBar();
            const track = { tick, el: bar, tickDuration };
            api.clickTrack.left = track;
          } else {
            // set right bar
            if (!api.clickTrack.right) {
              const tickDuration = api._currentBeat.tickDuration;
              const bar = await genTrackBar();
              const track = { tick, el: bar, tickDuration };
              api.clickTrack.right = track;

              if (api.clickTrack.left.tick > api.clickTrack.right.tick) {
                // revert correct order
                [api.clickTrack.right.tick, api.clickTrack.left.tick] = [
                  api.clickTrack.left.tick,
                  api.clickTrack.right.tick,
                ];
              }
              // complete range
              api.playbackRange = {
                startTick: api.clickTrack.left.tick - 1,
                endTick:
                  api.clickTrack.right.tick +
                  api.clickTrack.right.tickDuration -
                  1,
              };
            } else {
              clearPlaybackRange();
            }
          }
        }

        function onBeatChange(beat, isLost) {
          const signal = beat.notes.map((note) => ({
            key: note.string,
            value: note.fret,
            effect: [
              0, //8
              note.isTapped ? 4 : 0, //9
              note.bendType === BendType.None
                ? 0
                : note.bendType === BendType.PrebendRelease
                ? 1
                : 2, //10
              note.isPalmMute ? 8 : 0, //11
              note.harmonicType === HarmonicType.None ? 0 : 3, //12
              beat.isPalmMute ? 8 : 0, //13
              note.isDead ? 1 : 0, //14
              0, // 15
            ],
          }));
          // console.log("send beat", beat, signal);
          emitEventToApp({
            event: "onPlayedBeatChanged",
            payload: { signal },
          });
        }
        api.renderStarted.on(() => {
          loader.style.display = "flex";
          emitEventToApp({
            event: "onRenderStarted",
            payload: {
              runningTracks: api.tracks.map((track) => trackToJSON(track)),
            },
          });
        });
        api.renderFinished.on(() => {
          loader.style.display = "none";
          api.trackTickList = api._tickCache.masterBars;
          api.lastTimePosition = api.timePosition;
          api.lostBeatTimeCount = 0;
          api.lostBeatStack = [];
          api.baseBeat = null;
          onOffTrack(api.tracks[0]);
          emitEventToApp({
            event: "onRenderFinished",
            runningTracks: api.tracks.map((track) => trackToJSON(track)),
          });
        });

        api.scoreLoaded.on((score) => {
          window.hashTracks = {};
          emitEventToApp({
            event: "onScoreLoaded",
            payload: {
              title: score.title,
              artist: score.artist,
              tracks: score.tracks.map((track) => {
                track.id = track.index;
                track.playbackInfo.isOn = true;
                const obj = trackToJSON(track);
                hashTracks[obj.id] = track;
                return obj;
              }),
            },
          });
        });

        api.soundFontLoad.on((e) => {
          const percentage = Math.floor((e.loaded / e.total) * 100);
          emitEventToApp({
            event: "onSoundFontLoad",
            payload: { percentage },
          });
        });
        api.playerReady.on(() => {
          emitEventToApp({
            event: "onPlayerReady",
          });
        });

        api.playerStateChanged.on((e) => {
          emitEventToApp({
            event: "onPlayerStateChanged",
            payload: { state: e.state },
          });
        });

        function handleBeatTime(currentTime) {
          if (api.baseBeat) {
            for (const beat of api.lostBeatStack) {
              const startTick = beat.displayStart - api.baseBeat.displayStart;
              const startTime =
                ticksToMillis(startTick, api.score.tempo) / api.playbackSpeed;
              if (currentTime >= startTime) {
                onBeatChange(beat, true);
                // remove it after run
                api.lostBeatStack = api.lostBeatStack.filter(
                  (lost) => lost !== beat
                );
              }
            }
          }
        }

        api.playedBeatChanged.on(() => {
          const { nextBeatLookup, currentBeat } = api._currentBeat;
          const isSameNextBeat =
            nextBeatLookup?.beat?.id === currentBeat.nextBeat.id;
          const nextBeatId =
            nextBeatLookup?.beat?.id ?? currentBeat.nextBeat.id;

          const delta = nextBeatId - currentBeat.id;
          if (!isSameNextBeat && delta > 1) {
            // run lost beats
            api.lostBeatTimeCount = 0;
            const nextBeats = [];
            let iBeat = currentBeat;
            Array.from({ length: delta - 1 }).forEach((_) => {
              iBeat = iBeat.nextBeat;
              nextBeats.push(iBeat);
            });
            api.baseBeat = currentBeat;
            api.lostBeatStack = nextBeats;
            onBeatChange(currentBeat);
          } else {
            onBeatChange(currentBeat);
          }
        });

        api.beatMouseDown.on((e) => {
          api.clicked = true;
        });

        api.playerPositionChanged.on((e) => {
          if (e.isSeek && api.clicked) {
            handleClickLine(e.currentTick);
            api.clicked = false;
          }
          const delta = api.timePosition - api.lastTimePosition;
          api.lastTimePosition = api.timePosition;

          api.lostBeatTimeCount += delta;
          handleBeatTime(api.lostBeatTimeCount);

          emitOnPlayerPositionChanged({
            currentTime: e.currentTime,
            endTime: e.endTime,
          });
        });
      }

      setTimeout(() => {
        const [, flag] = window.location.hash?.split("#");
        if (flag === "debug") {
          console.log("bootstrap called by debug");
          bootstrap("./walk.gp5");
          setTimeout(() => {
            window.sheetEngine.playbackSpeed = 0.1;
            playTrack(2);
            setTimeout(() => {
              toggleRangeMode();
            }, 100);
          }, 100);
        }
      }, 0);
    </script>
  </body>
</html>
