<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>GuitaTabNavi AlphTab</title>
    <!-- <script src="https://cdn.jsdelivr.net/npm/@coderline/alphatab@latest/dist/alphaTab.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/@coderline/alphatab@1.2.3/dist/alphaTab.min.js"></script>
    <script src="kit.fontawesome.js"></script>
    <script src="debounce.min.js"></script>
    <style type="text/css">
      body {
        font-family: Arial, Helvetica, sans-serif;
        font-size: 12px;
        margin: 0;
        padding: 0;
      }

      .at-wrap {
        width: 100vw;
        height: 100vh;
        position: relative;
        overflow: hidden;
      }
      .at-viewport {
        overflow-y: auto;
        max-height: 100%;
      }

      .at-main {
        pointer-events: all;
        -webkit-touch-callout: none; /* iOS Safari */
        -webkit-user-select: none; /* Safari */
        -khtml-user-select: none; /* Konqueror HTML */
        -moz-user-select: none; /* Old versions of Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
        user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome, Edge, Opera and Firefox */
      }

      .at-cursor-bar:not(.range-mode) {
        /* Defines the color of the bar background when a bar is played */
        background: rgba(255, 242, 0, 0.25);
      }

      .track-bar {
        position: absolute;
        background-color: #27ae60;
        z-index: 2;
        width: 4px;
      }

      .track-bar > div {
        position: relative;
        width: 100%;
        height: 100%;
      }
      .track-bar > div::before {
        content: "";
        position: absolute;
        top: 0;
        left: 50%;
        width: 0px;
        height: 0px;
        border-left: 16px solid transparent;
        border-right: 16px solid transparent;
        border-top: 32px solid #27ae60;
        border-bottom: 32px solid transparent;
        transform: translateX(calc(-50%));
      }

      .track-bar > div::after {
        content: "";
        position: absolute;
        bottom: 0;
        left: 50%;
        width: 0px;
        height: 0px;
        border-left: 16px solid transparent;
        border-right: 16px solid transparent;
        border-bottom: 32px solid #27ae60;
        border-top: 32px solid transparent;
        transform: translateX(calc(-50%));
      }
      .at-surface.highlight > div:nth-child(n + 4):nth-last-child(n + 3) {
        /* border: 2px solid rgba(56, 68, 234, 0.763); */
        background-color: #7fbafd15;
      }
      .at-selection > div {
        /* Defines the color of the selection background */
        /* background-color: #27ae5f69; */
        background-color: transparent;
        position: relative;
      }

      .at-cursor-beat {
        /* Defines the beat cursor */
        background: rgba(64, 64, 255, 0.75);
        width: 3px;
      }

      .at-highlight * {
        /* Defines the color of the music symbols when they are being played (svg) */
        fill: #0078ff;
        stroke: #0078ff;
      }

      .loader {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #ffffff30;
      }

      .my-btn {
        width: 120px;
        height: 90px;
        background-color: #0078ff;
        color: #fff;
        position: fixed;
        top: 20px;
        right: 20px;
        z-index: 444;
        user-select: none;
      }

      .my-btn-resume {
        width: 120px;
        height: 90px;
        background-color: #0078ff;
        color: #fff;
        position: fixed;
        top: 20px;
        right: 150px;
        z-index: 444;
        user-select: none;
      }
    </style>
  </head>

  <body>
    <template id="tl_track-bar">
      <div class="track-bar">
        <div></div>
      </div>
    </template>
    <div class="at-wrap">
      <button class="my-btn" onmouseup="onstart();">Start</button>
      <button class="my-btn-resume" onmouseup="onresume();">Resume</button>
      <div class="at-viewport">
        <div class="at-main"></div>
      </div>
      <div id="loader" class="loader">
        <img src="./loading.svg" alt="" />
      </div>
    </div>

    <script type="text/javascript">
      console.log("xxxx");
      // load elements
      const wrapper = document.querySelector(".at-wrap");
      const main = wrapper.querySelector(".at-main");
      const loader = document.getElementById("loader");
      const viewport = wrapper.querySelector(".at-viewport");

      function ticksToMillis(ticks, tempo) {
        return (ticks * (60000.0 / (tempo * 960))) | 0;
      }

      function trackToJSON(track) {
        return {
          id: track.index,
          name: track.name,
          isMute: getTrackMuteState(track),
        };
      }

      function getTrackMuteState(track) {
        if (track.playbackInfo.isOn) {
          return false; // currently not mute yet
        }
        return true;
      }

      function onOffTrack(track) {
        window.sheetEngine.changeTrackMute([track], getTrackMuteState(track)); // mute or on track
      }

      function getCapo(track) {
        const capo = track.staves.find(
          (stave) => stave.capo /*capo > 0 or != null*/
        )?.capo;

        return capo;
      }

      async function genTrackBar() {
        await new Promise((res) => setTimeout(res, 200));
        const runBar = main.querySelectorAll(".at-cursor-beat")[0];

        // get position from translate
        const pos = (runBar.style.transform.match(
          /translate\(([0-9|\.]+px,\s?[0-9|\.]+px)\)/
        ) || [])[1]?.split(/,\s?/);

        // get scale from translate
        const scale = (runBar.style.transform.match(
          /scale\(([0-9|\.]+,\s?[0-9|\.]+)\)/
        ) || [])[1]?.split(/,\s?/);

        const height = runBar.style.height;

        const trackBar = document
          .getElementById("tl_track-bar")
          .content.cloneNode(true);
        trackBar.children[0].setAttribute(
          "style",
          `left:${pos[0]}; top:${pos[1]}; height: calc(${height} * ${scale[1]})`
        );

        runBar.parentElement.appendChild(trackBar);

        return trackBar;
      }

      function clearPlaybackRange() {
        const sheetEngine = window.sheetEngine;
        sheetEngine.clickTrack = {};
        sheetEngine.playbackRange = null;
        // clear all bar
        const bars = main.querySelectorAll(".track-bar");
        bars.forEach((bar) => bar.remove());
      }

      function onRangeMode() {
        const atCursor = main.querySelector(".at-cursors");
        const surface = main.querySelector(".at-surface");
        window.sheetEngine.isLooping = true;
        window.sheetEngine.createRangeMode = true;
        surface.classList.add("highlight");
        atCursor.querySelector(".at-cursor-bar").classList.add("range-mode");
        emitEventToApp({
          event: "onRangeModeChanged",
          payload: true,
        });
      }

      function offRangeMode() {
        const atCursor = main.querySelector(".at-cursors");
        const surface = main.querySelector(".at-surface");
        window.sheetEngine.isLooping = false;
        window.sheetEngine.createRangeMode = false; // set flag off

        // off range mode style
        surface.classList.remove("highlight");
        atCursor.querySelector(".at-cursor-bar").classList.remove("range-mode");
        clearPlaybackRange();

        //
        emitEventToApp({
          event: "onRangeModeChanged",
          payload: false,
        });
      }

      function toggleRangeMode() {
        window.sheetEngine.pause();
        if (!window.sheetEngine.createRangeMode) {
          onRangeMode();
        } else {
          offRangeMode();
        }
      }

      function replaySheet() {
        // off range mode before reset
        offRangeMode();
        window.sheetEngine.player.timePosition = 0;
        window.sheetEngine.updateSettings();
        window.sheetEngine.render();
      }

      function playTrack(id) {
        // off range mode before change track
        offRangeMode();
        const track = window.hashTracks[id];
        window.sheetEngine.renderTracks([track]);
      }

      function toggleTrackVolume(id) {
        const track = window.hashTracks[id];
        track.playbackInfo.isOn = !track.playbackInfo.isOn;
        emitEventToApp({
          event: "onTrackMuteChanged",
          payload: {
            id: id,
            mute: getTrackMuteState(track),
          },
        });
        onOffTrack(track);
      }

      function playAtTime(fraction) {
        window.sheetEngine.player.timePosition =
          fraction * window.sheetEngine.endTimePosition;

        window.sheetEngine.updateSettings();
        window.sheetEngine.render();
      }

      window.emitEventToApp = window.ReactNativeWebView
        ? function (obj) {
            window.ReactNativeWebView.postMessage(
              `event::${JSON.stringify(obj)}`
            );
          }
        : function noop() {};

      const emitOnPlayerPositionChanged = _.throttle(
        ({ api, currentTick, endTick }) => {
          // just set total time once not continuous
          if (!api.totalTime) {
            api.totalTime = ticksToMillis(endTick, api.score.tempo); // not change even speed rate change
          }

          emitEventToApp({
            event: "onPlayerPositionChanged",
            payload: {
              currentTime: ticksToMillis(currentTick, api.score.tempo), // not change even speed rate change
              endTime: api.totalTime,
            },
          });
        },
        10
      );

      async function bootstrap(data) {
        window.hashTracks = {};

        if (window.sheetEngine) {
          window.sheetEngine.stop();
          window.sheetEngine.destroyPlayer();
          window.sheetEngine = undefined;
        }
        // initialize alphatab
        const HarmonicType = alphaTab.model.HarmonicType;
        const BendType = alphaTab.model.BendType;
        const api = new alphaTab.AlphaTabApi(main, {
          file: data,
          player: {
            enablePlayer: true,
            soundFont: "./sonivox.sf2",
            scrollElement: viewport,
          },
        });

        //   api.countInVolume = 1;
        //   api.metronomeVolume = 1;
        //   api.isLooping = loop.classList.contains("active");

        //   api.settings.display.layoutMode = alphaTab.LayoutMode.Horizontal;
        //   api.settings.display.layoutMode = alphaTab.LayoutMode.Page;

        api.settings.display.scale = 2;
        api.isLooping = false;
        api.playbackRange = null;
        api.totalTick = null;
        api.clickTrack = { left: null, right: null };
        api.createRangeMode = false;
        api.trackTickList = [];
        api.lastTimePosition = 0;
        api.endTimePosition = 0;
        window.sheetEngine = api;

        async function handleClickLine(tick) {
          if (!api.createRangeMode) {
            return;
          }
          api.pause();

          if (!api.clickTrack.left) {
            // set left bar
            const displayDuration =
              api._currentBeat.currentBeat.displayDuration;
            const bar = await genTrackBar();
            const track = { tick, el: bar, displayDuration };
            api.clickTrack.left = track;
          } else {
            // set right bar
            if (!api.clickTrack.right) {
              const displayDuration =
                api._currentBeat.currentBeat.displayDuration;
              const bar = await genTrackBar();
              const track = { tick, el: bar, displayDuration };
              api.clickTrack.right = track;

              if (api.clickTrack.left.tick > api.clickTrack.right.tick) {
                // revert correct order
                [api.clickTrack.right.tick, api.clickTrack.left.tick] = [
                  api.clickTrack.left.tick,
                  api.clickTrack.right.tick,
                ];
              }
              // complete range
              // Normally endTick = api.clickTrack.right.tick + api.clickTrack.right.displayDuration - 1 but there some cases that next note was reached out. To prevent next note was not reached out, we munus 10 tick to endTick
              api.playbackRange = {
                startTick: api.clickTrack.left.tick - 1,
                endTick:
                  api.clickTrack.right.tick +
                  api.clickTrack.right.displayDuration -
                  10,
              };
            } else {
              clearPlaybackRange();
            }
          }
        }

        function getNoteEffect(beat, note, index) {
          if (beat.tap) {
            return 4;
          }
          if (note.bendType !== BendType.None) {
            // BendTypeがReleaseもしくはPrebendReleaseのとき
            if (
              note.bendType === BendType.Release ||
              note.bendType === BendType.PrebendRelease
            ) {
              return 2;
            } else {
              // BendTypeがRelease、PrebendRelease以外のとき
              return 1;
            }
          }

          // Tieのとき, 前の音符がbendType = 4 (BendRelease)のnoteが来たらチョークアップ（サブ表示コマンド：１）を表示し、次の音符が、
          // 前の音と同じString、fretで且つbendTypeが０（None）の場合には、チョークダウン（サブ表示コマンド：2）を表示する。
          if (note.bendType == BendType.None && note.isTieDestination) {
            const noteOfPreviousBeat = beat.previousBeat.notes[index];
            if (noteOfPreviousBeat) {
              if (
                noteOfPreviousBeat.bendType == BendType.BendRelease &&
                noteOfPreviousBeat.fret == note.fret &&
                noteOfPreviousBeat.string == note.string
              ) {
                return 2;
              }
            }
          }

          if (!note.isDead && beat.isPalmMute) {
            return 8;
          }

          if (note.harmonicType !== HarmonicType.None) {
            return 3;
          }

          return 0;
        }

        // 6弦⇔1弦、5弦⇔2弦、4弦⇔3弦、3弦⇔4弦、2弦⇔5弦、１弦⇔６弦への修正
        const convertValues = (value) =>
          ({ 1: 6, 2: 5, 3: 4, 4: 3, 5: 2, 6: 1 }[value] || value);

        function getHarmonicFret(note) {
          return note.harmonicType === HarmonicType.None ? 0 : note.fret;
        }

        function onBeatChange(beat, isLost) {
          let summaryDeadFlag = beat.notes.length ? true : false;
          // beat.notes[0].harmonicType = HarmonicType.Tap; // DEBUG
          const isBeatHaveHarmonicType = beat.notes.some(
            (note) => note.harmonicType !== HarmonicType.None
          );
          const signal = beat.notes.map((note, index) => {
            summaryDeadFlag = summaryDeadFlag && note.isDead;
            return {
              key: convertValues(note.string),
              // default value = note.fret
              // if note is harmonic, value = getHarmonicFret(note)
              // if note is dead, value = 255
              value: isBeatHaveHarmonicType
                ? getHarmonicFret(note)
                : note.isDead
                ? 255
                : note.fret,
              effect: getNoteEffect(beat, note, index),
            };
          });

          emitEventToApp({
            event: "onPlayedBeatChanged",
            payload: { signal, isDead: summaryDeadFlag },
          });
        }
        api.renderStarted.on(() => {
          loader.style.display = "flex";
          emitEventToApp({
            event: "onRenderStarted",
            payload: {
              runningTracks: api.tracks.map((track) => trackToJSON(track)),
            },
          });
        });
        api.renderFinished.on(() => {
          loader.style.display = "none";
          api.trackTickList = api._tickCache.masterBars;
          api.lastTimePosition = api.timePosition;
          api.lostBeatTimeCount = 0;
          api.lostBeatStack = [];
          api.baseBeat = null;
          api.lastPlayedBeat = null;
          api.totalTime = 0;
          // onOffTrack(api.tracks[0]);
          emitEventToApp({
            event: "onRenderFinished",
            payload: {
              runningTracks: api.tracks.map((track) => trackToJSON(track)),
              capo: getCapo(api.tracks[0]),
            },
          });
        });

        api.scoreLoaded.on((score) => {
          window.hashTracks = {};
          emitEventToApp({
            event: "onScoreLoaded",
            payload: {
              title: score.title,
              artist: score.artist,
              tracks: score.tracks.map((track) => {
                track.id = track.index;
                track.playbackInfo.isOn = true;
                const obj = trackToJSON(track);
                hashTracks[obj.id] = track;
                return obj;
              }),
            },
          });
        });

        api.soundFontLoad.on((e) => {
          const percentage = Math.floor((e.loaded / e.total) * 100);
          emitEventToApp({
            event: "onSoundFontLoad",
            payload: { percentage },
          });
        });
        api.playerReady.on(() => {
          emitEventToApp({
            event: "onPlayerReady",
          });
        });

        api.playerStateChanged.on((e) => {
          api.lastPlayedBeat = null;
          emitEventToApp({
            event: "onPlayerStateChanged",
            payload: { state: e.state },
          });
        });

        function handleBeatTime(currentTime) {
          if (api.baseBeat) {
            for (const beat of api.lostBeatStack) {
              const startTick = beat.displayStart - api.baseBeat.displayStart;
              const startTime =
                ticksToMillis(startTick, api.score.tempo) / api.playbackSpeed;
              if (currentTime >= startTime) {
                onBeatChange(beat, true);
                // remove it after run
                api.lostBeatStack = api.lostBeatStack.filter(
                  (lost) => lost !== beat
                );
              }
            }
          }
        }

        api.playedBeatChanged.on(() => {
          if (!api._currentBeat) {
            return;
          }
          const { nextBeatLookup, currentBeat } = api._currentBeat;
          if (api.lastPlayedBeat == currentBeat) {
            // skip same beat
            return;
          }
          api.lastPlayedBeat = currentBeat;
          if (!currentBeat.nextBeat) {
            onBeatChange(currentBeat);
            return;
          }
          const isSameNextBeat =
            nextBeatLookup?.beat?.id === currentBeat.nextBeat.id;
          const nextBeatId =
            nextBeatLookup?.beat?.id ?? currentBeat.nextBeat.id;

          const delta = nextBeatId - currentBeat.id;
          if (!isSameNextBeat && delta > 1) {
            // find lost beats
            api.lostBeatTimeCount = 0;
            const nextBeats = [];
            let iBeat = currentBeat;

            let iCount = 0;
            const limit = 100; // to much lost beat ????
            while (true) {
              iBeat = iBeat.nextBeat;
              if (iBeat.id == nextBeatId) {
                // stop find lost beat
                break;
              }
              nextBeats.push(iBeat);
              iCount++;
              if (iCount >= limit) {
                // stop find lost beat
                break;
              }
            }
            api.baseBeat = currentBeat;
            api.lostBeatStack = nextBeats;
            onBeatChange(currentBeat);
          } else {
            onBeatChange(currentBeat);
          }
        });

        api.beatMouseDown.on((e) => {
          api.clicked = true;
        });

        api.playerPositionChanged.on((e) => {
          if (e.isSeek && api.clicked) {
            handleClickLine(e.currentTick);
            api.clicked = false;
          }
          const delta = api.timePosition - api.lastTimePosition;
          api.lastTimePosition = api.timePosition;

          api.lostBeatTimeCount += delta;
          handleBeatTime(api.lostBeatTimeCount);

          if (e.endTime) {
            api.endTimePosition = e.endTime; // this will update when speed rate change
          }

          emitOnPlayerPositionChanged({
            api,
            currentTick: e.currentTick,
            endTick: e.endTick,
          });
        });
      }

      setTimeout(() => {
        const [, flag] = window.location.hash?.split("#");
        if (flag === "debug") {
          console.log("bootstrap called by debug");
          bootstrap("./canon.gp");
          //   window.sheetEngine.playbackSpeed = 0.1;
          //   playTrack(2);
          //   setTimeout(() => {
          //     toggleRangeMode();
          //   }, 100);
          // }, 100);
        }
      }, 0);

      async function onresume() {
        myctx.resume().then(() => {
          console.log("resume success");
        });
      }

      async function onstart() {
        // window.ReactNativeWebView?.postMessage("start");
        sheetEngine.play();
        // window.location.reload();
      }
    </script>
  </body>
</html>
